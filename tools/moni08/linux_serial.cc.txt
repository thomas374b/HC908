/*-----------------------------------------------------------------------------
Project name	:	khep_serial
Filename	:	khep_serial.c
Release		:	0.1 bis
Purpose		:	Basic Package for communications with Khepera through
                        the serial line
Creation date	:	17/11/93
Author		:	M. von Holzen, L. Tettoni
Releaser        :       J.-Y. Tigli, O. Michel
History         :       0.1	17/11/93	Creation
                        0.1 bis 14/03/94        Modification
                        0.1 ter 21/09/95        Modification
-----------------------------------------------------------------------------*/



#undef VERSION
#define VERSION "0.1"

#undef REVISION
#define REVISION "21/09/95"

#define AUTHOR "M. von Holzen, L. Tettoni"
#include "tns_util/copyright.h"



// #include "fileNameFromDesc.h"

/* Try to empty input buffer  */
void serial_drain(int fd, bool verbose)
{
  char answer[KHEP_MSG_SIZE];
  int  rsize;

  do
  {
    rsize = serial_readline(fd,answer,sizeof(answer));
    if (verbose) fprintf (stderr,"draining %d bytes",rsize);
  }
  while (rsize > 0); /* Read till nothing more to read */
}

/* Khepera package routines                                                 */
/* These routine make a specific use of the serial management functions to  */
/* provide a more complex tool to communicate with a Khepera                */

/* Send line send           */
/* and receive line receive */
/* without any check control*/
extern bool khep_send_recv(int fd,char *send,char *receive,int recv_len)
{
  int rd;

  serial_write(fd,send,strlen(send));

  if ((rd = serial_readline(fd,receive,recv_len)) > 0 )
	  return(true);
  else
  {
    if (rd < 0) perror("khepera_send_recv(): read error");
    else perror("khepera_send_recv(): khepera not responding");
    return(false);
  }
}

/* Send line send and receive line       */
/* receive with check control :          */
/* The first character of the received   */
/* line is the lower first character of  */
/* the send line.                        */
/* Try to have the good answer           */
/* KHEP_NB_RETRY times                   */
extern bool khep_talk(int fd,char *send,char *receive,int recv_len)
{
  int  rd,rsize,tries = 0;
  char respond = tolower(send[0]);

  do
  {
    serial_write(fd,send,strlen(send));
    rd = serial_readline(fd,receive,recv_len);
    if (rd < 0) /* File error */
    {
      perror("khep_talk(): read/write error");
      break;
    }
    else if (rd == 0) /* No response */
    tries++;
    else if (receive[0] != respond) /* Incorrect answer */
    {
      perror("khep_talk(): protocol error");
      serial_drain(fd,false);
      tries++;
    }
    else /* Correct answer */
    {
      if ((rsize = strlen(receive)) >= 2) /* Strip terminating '\r\n' if any */
      {
        if (receive[rsize-1] == '\n') receive[rsize-1] = '\0';
        if (receive[rsize-2] == '\r') receive[rsize-2] = '\0';
      }
      return(true);
    }
  }
  while (tries < KHEP_NB_RETRY);
  if (rd == 0) perror("khep_talk(): Khepera not responding");
  return(false);
}



void serial_talk(int fd,char s[1024])
{
    unsigned int i,j;
    char st[1024],*s2;

    sprintf(st,"%s\n",s);
    i = strlen(st);
  
#ifdef DEBUG
    fprintf(stderr,"going to write [%s]\n",s);
#endif    

    write(fd,st,i);

#ifdef DEBUG
    fprintf(stderr,"going to read\n");
#endif    
    j = serial_readline(fd,st,1024);

    for (i=0;i<strlen(&st[0]);i++)
      if (st[i] < 32)
         st[i] = 32; 

    s2 = strchr(st,32);
    if (s2 != NULL)
       *s2 = '\0';

    strcpy(s,st);
}




// end of file

// end of file







/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/*****  End Of File  ****************************/
